export const MARKDOWN_EXAMPLE = {
  description: "useCallback is a React Hook that lets you cache a function definition between re-renders.\r\n\r\n`const cachedFn = useCallback(fn, dependencies)`\r\n\r\n### Reference\r\n\r\nCall useCallback at the top level of your component to cache a function definition between re-renders:\r\n\r\n```jsx\r\nimport { useCallback } from 'react';\r\n\r\nexport default function ProductPage({ productId, referrer, theme }) {\r\n  const handleSubmit = useCallback((orderDetails) => {\r\n    post('/product/' + productId + '/buy', {\r\n      referrer,\r\n      orderDetails,\r\n    });\r\n  }, [productId, referrer]);\r\n```\r\n\r\n### Parameters\r\n\r\n- fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On subsequent renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\r\n- dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://beta.reactjs.org/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm.\r\n\r\n### Returns\r\n\r\nOn the initial render, useCallback returns the fn function you have passed.\r\n\r\nDuring subsequent renders, it will either return an already stored fn  function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render.\r\n\r\n### Caveats\r\n\r\n- useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.\r\n- React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a [state variable](https://beta.reactjs.org/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead) or a [ref](https://beta.reactjs.org/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.\r\n- \r\n\r\n### Usage\r\n\r\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.\r\n\r\nTo cache a function between re-renders of your component, wrap its definition into the useCallback Hook:\r\n\r\n```jsx\r\nimport { useCallback } from 'react';\r\n\r\nfunction ProductPage({ productId, referrer, theme }) {\r\n  const handleSubmit = useCallback((orderDetails) => {\r\n    post('/product/' + productId + '/buy', {\r\n      referrer,\r\n      orderDetails,\r\n    });\r\n  }, [productId, referrer]);\r\n  // ...\r\n```\r\n\r\nYou need to pass two things to useCallback:\r\n\r\n1. A function definition that you want to cache between re-renders.\r\n2. A list of dependencies including every value within your component that’s used inside your function.\r\n\r\nOn the initial render, the returned function you’ll get from useCallback will be the function you passed.\r\n\r\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render.\r\n\r\nIn other words, useCallback caches a function between re-renders until its dependencies change.\r\n\r\nLet’s walk through an example to see when this is useful.\r\n\r\nSay you’re passing a handleSubmit function down from the ProductPage to the ShippingForm component:\r\n\r\n```jsx\r\nfunction ProductPage({ productId, referrer, theme }) {\r\n  // ...\r\n  return (\r\n    <div className={theme}>\r\n      <ShippingForm onSubmit={handleSubmit} />\r\n    </div>\r\n  );\r\n```\r\n\r\nYou’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the ShippingForm component.\r\n\r\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in [memo:](https://beta.reactjs.org/reference/react/memo)\r\n\r\n```jsx\r\nimport { memo } from 'react';\r\n\r\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\r\n  // ...\r\n});\r\n```\r\n\r\nWith this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is where caching a function becomes important! Imagine that you defined handleSubmit without useCallback:\r\n\r\n```jsx\r\nfunction ProductPage({ productId, referrer, theme }) {\r\n  // Every time the theme changes, this will be a different function...\r\n  function handleSubmit(orderDetails) {\r\n    post('/product/' + productId + '/buy', {\r\n      referrer,\r\n      orderDetails,\r\n    });\r\n  }\r\n  \r\n  return (\r\n    <div className={theme}>\r\n      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}\r\n      <ShippingForm onSubmit={handleSubmit} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\nIn JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that ShippingForm props will never be the same, and your [memo](https://beta.reactjs.org/reference/react/memo) optimization won’t work. This is where useCallback comes in handy:\r\n\r\n```jsx\r\nfunction ProductPage({ productId, referrer, theme }) {\r\n  // Tell React to cache your function between re-renders...\r\n  const handleSubmit = useCallback((orderDetails) => {\r\n    post('/product/' + productId + '/buy', {\r\n      referrer,\r\n      orderDetails,\r\n    });\r\n  }, [productId, referrer]); // ...so as long as these dependencies don't change...\r\n\r\n  return (\r\n    <div className={theme}>\r\n      {/* ...ShippingForm will receive the same props and can skip re-rendering */}\r\n      <ShippingForm onSubmit={handleSubmit} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n"
}